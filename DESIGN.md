# Архитектура интерпретатора командной строки hsesh

## Команда
- Бубнов Данил
- Онофрийчук Илья
- Марьин Глеб
- Лучинин Алексей

## Структура программы в виде диаграмы:
![Диаграмма классов](images/class_diagram.svg)

## Компоненты

### Env
Отвечает за переменные окружения

Умеет:
- присвоить какой-то переменной значение
- сказать значение конкретной переменной
- отдать весь список переменных и их значений

### CLI
Отвечает за ввод и вывод в консоль

Умеет:
- считывать очередное выражение (строку)
- вернуть поток ввода
- вывести строку или поток байт в консоль

### AssignmentValidator
Отвечает за присваивания

Умеет:
- проверить, является ли выражение присваиванием
- вернуть переменную и присваиваемое значение

Алгоритм: если в выражении есть =, то разбиваем выражение по первому =; проверяем, является ли левая часть валидным именем переменной (с помощью [VarNameValidator](#varnamevalidator)), а правая валидным токеном (с помощью [Tokenizer](#tokenizer))

Примеры корректных присваиваний:
- a=3dF_
- a=$b
- a=" = | ' $b "
- a=' = | " $b '
- a=3'3 3'3
- a=" 3 3 "
- a=' 3 3 '
- a=' $b '" $b "' 3 '
- a=3'|'
- a=3"="

Примеры некорректных присваиваний:
- a= 3
- a =3
- a = 3
- a=3"
- a=3'
- a='3
- a="3
- a=3|
- a=3=
- a=3 3
- a=$b b
- a=" 3 "|' 3 '

### Tokenizer
Отвечает за разбиение на токены

Умеет:
- разбить выражение на токены

Токен -- это одно из:
- |
- '[^']*'
- "[^"]*"
- [^'"|=]+
- конкатенация последних трех

Примеры корректных токенов:
- |
- '3 = | "$a" $a '
- "3 = | '$a' $a "
- Lesha9
- 9'='3"^"2
- 9'='9
- "9="9
- "3""4"

### Substitutor
Отвечает за подстановку переменных

Умеет:
- заменить переменные в токене на их значения и убирает кавычки

Алгоритм: идем циклом по символам токена, мы можем находиться в одном из 3 состояний: 1) в одинарных кавычках 2) в двойных кавычках 3) вне кавычек. Если мы внутри двойных или вне кавычек и встречаем $, то с помощью [VarNameValidator](#varnamevalidator) находим длину валидного имени переменной (если она 0, то ошибка), после чего заменяем переменную на её значение и продолжаем цикл с символа после названия переменной

Примеры подстановок (a=9):
- '3 = | "$a" $a' не изменится
- "3 = | '$a' $a" -> 3 = | '9' 9
- Lesha$a -> Lesha9
- "$ab" -> пустая строка
- "$a=b" -> 9=b
- "$a|b" -> 9|b

### PipeSpliter
Отвечает за разбиение пайпа на команды (списки токенов)

Умеет:
- поделить список токенов по токену |

### CommandFactory
Отвечает за создание команд

Умеет:
- зарегистрировать свою команду (cat, echo, ...)
- сделать из списка токенов команду

Алгоритм: Первый токен — название команды, остальные — аргументы. Если название команды зарегистрировано, то возвращает нашу реализацию, которой передаются аргументы в конструктор. Иначе будет подготовлен к запуску системный процесс, будут сразу же переданы аргументы, будут проставлены переменные окружения для него (нужен доступ к [Env](#env)) (например, с помощью [ProcessBuilder](https://docs.oracle.com/javase/8/docs/api/java/lang/ProcessBuilder.html))

Итоговая команда имеет методы:
- run(InputStream, OutputStream, ErrorStream): ExitCode
- isExit(): Bool

### PipeFactory
Отвечает за создание пайпа

Умеет:
- Создать пайп (реализует интерфейс команды) из списка команд

Пайп исполняет команды последовательно, проверяет, является ли команда exit с помощью метода isExit() (Если является, то прекращает выполнение, возвращает 0), проверяет ExitCode каждой команды (если он отличен от 0, то заканчивает выполнение и возвращает этот код), направляет вывод одной команды на вход следующей.

### VarNameValidator
Отвечает за валидацию имен переменных

Умеет:
- проверить, является ли строка валидным именем переменной
- найти длину валидного имени переменной в строке, начиная с начала строки (у "ab3 a" длина равна 3)

Имя валидное, если подходит под регулярное выражение [_a-zA-Z][_a-zA-Z0-9]*

### MainExecutor
Отвечает за объединение всех компонентов

0. Регистрирует команды cat, echo, ... в [CommandFactory](#commandfactory)
1. Просит у [CLI](#cli) очередное выражение
2. Спрашивает у [AssignmentValidator](#assignmentvalidator), является ли выражение присваиванием
    - Если является, то записываем в [Env](#env) значение и переходим к шагу 1
    - Иначе идет дальше
3. Передает [Tokenizer](#tokenizer) выражение, он возвращает нам список токенов
4. Заменяет в каждом токене переменные с помощью [Substitutor](#substitutor)
5. Бьет список токенов на списки токенов (будущие команды) с помощью [PipeSpliter](#pipespliter)
6. Превращает списки токенов в команды с помощью [CommandFactory](#commandfactory)
7. Превращает список команд в пайп, реализующий интерфейс команды, с помощью [PipeFactory](#pipefactory) 
8. Просит у [CLI](#cli) поток ввода, вывода и ошибок, передает их в пайп, проверяет ExitCode и isExit() у пайпа
    - Если isExit() true, то заканчивает работу
    - Иначе переходит к шагу 1

То же самое в виде диаграммы
![Диаграмма](images/diagram.svg)

## Примеры работы

```cat example.txt | wc```

Разбор:
1. CLI возвращает MainExecutor *cat example.txt | wc*
2. AssignmentValidator говорит, что это выражение не является присваиванием
3. Tokenizer из *cat example.txt | wc* получает [*cat*, *example.txt*, *|*, *wc*]
4. Substitutor ничего не изменяет
5. PipeSpliter из [*cat*, *example.txt*, *|*, *wc*] получает [[*cat*, *example.txt*], [*wc*]]
6. CommandFactory из [*cat*, *example.txt*], [*wc*]] получает [*CatCommand*, *WcCommand*]
7. PipeFactory из [*CatCommand*, *WcCommand*] получает пайп
8. MainExecutor получает от CLI поток ввода, вывода и ошибок, передает их в пайп, пайп возвращает ExitCode 0 и isExit() == false

```FILE=example.txt```

Разбор:
1. CLI возвращает MainExecutor-у *FILE=example.txt*
2. AssignmentValidator говорит, что это выражение является присваиванием. MainExecutor модифицирует Env: в переменную *FILE* записываем значение *example.txt*


```cat $FILE```

Разбор:
1. CLI возвращает MainExecutor *cat $FILE*
2. AssignmentValidator говорит, что это выражение не является присваиванием.
3. Tokenizer из *cat $FILE* получает [*cat*, *$FILE*]
4. Substitutor из [*cat*, *$FILE*] получает [*cat*, *example.txt*]
5. PipeSpliter из [*cat*, *example.txt*] получает [[*cat*, *example.txt*]]
6. CommandFactory из [[*cat*, *example.txt*]] получает [*CatCommand*]
7. PipeFactory из [*CatCommand*] получает пайп
8. MainExecutor получает от CLI поток ввода, вывода и ошибок, передает их в пайп, пайп возвращает ExitCode 0 и isExit() == false