# Архитектура интерпретатора командной строки hsesh

## Команда
- Бубнов Данил
- Онофрийчук Илья
- Марьин Глеб
- Лучинин Алексей

## Структурная диаграмма
![Диаграмма классов](images/class_diagram.svg)

## Компоненты

### Env
Отвечает за переменные окружения

Умеет:
- присвоить какой-то переменной значение
- сказать значение конкретной переменной
- отдать весь список переменных и их значений (которые хранит сам Env, а не его родитель)
Если Env не знает про какую-то переменную, то спрашивает про неё у родителя (системы)

### CLI
Отвечает за ввод и вывод в консоль

Умеет:
- считывать очередное выражение (строку)
- вернуть потоки ввода, вывода и ошибок
- вывести строку или поток байтов в консоль

### AssignmentParser
Отвечает за присваивания

Умеет:
- проверить, является ли выражение присваиванием
- вернуть переменную и присваиваемое значение

Алгоритм: если в выражении есть =, то разбиваем выражение по первому =; проверяем, является ли левая часть валидным именем переменной (с помощью [VarNameValidator](#varnamevalidator)), а правая валидным токеном (с помощью [Tokenizer](#tokenizer)). Если является, то с помощью [Substitutor](#substitutor) преобразуем токен и возвращаем пару (ключ, значение) 

Примеры корректных присваиваний:
- a=3dF_
- a=$b
- a=" = | ' $b "
- a=' = | " $b '
- a=3'3 3'3
- a=" 3 3 "
- a=' 3 3 '
- a=' $b '" $b "' 3 '
- a=3'|'
- a=3"="
- a=3=

Примеры некорректных присваиваний:
- a= 3
- a =3
- a = 3
- a=3"
- a=3'
- a='3
- a="3
- a=3|
- a=3 3
- a=$b b
- a=" 3 "|' 3 '

### PipeParser
Отвечает за пайпы

Умеет:
- проверить, является ли выражение пайпом
- вернуть список списков токенов

Алгоритм:
1. Передает [Tokenizer](#tokenizer) выражение, он возвращает нам список токенов
2. Бьет список токенов на списки токенов (будущие команды) с помощью [PipeSplitter](#pipesplitter)
3. Заменяет в каждом токене переменные с помощью [Substitutor](#substitutor) (сначала токенизировали, и разбили по |, а затем делаем подстановку, такое поведение схоже с поведением zsh)

Если на каком-то шаге произошла ошибка, то это не пайп

Примеры:
- `echo 3 | wc` --> `[[echo, 3], [wc]]`
- `echo 3 $v wc` ->> `[[echo, 3, |, wc]]` (`v='|'`)
- `echo$s=3` --> `[[echo =3]]` (`s=' '`)

### Tokenizer
Отвечает за разбиение на токены

Умеет:
- разбить выражение на токены

Токен -- это одно из:
- |
- '[^']*'
- "[^"]*"
- [^'"|\s]+
- конкатенация последних трех

Или одним регулярным выражением `(\||('[^']*'|"[^"]*"|[^'"|\s]+)+)`

Примеры корректных токенов:
- |
- '3 = | "$a" $a '
- "3 = | '$a' $a "
- Lesha9
- 9'='3"^"2
- 9'='9
- "9="9
- "3""4"

### Substitutor
Отвечает за подстановку переменных

Умеет:
- заменить переменные в токене на их значения и убирает кавычки

Алгоритм: идем циклом по символам токена, мы можем находиться в одном из 3 состояний: 1) в одинарных кавычках 2) в двойных кавычках 3) вне кавычек. Из 3 состояния можно перейти в 1 или 2, из 1 только в 3, из 2 только в 3. Если мы внутри двойных или вне кавычек и встречаем $, то с помощью [VarNameValidator](#varnamevalidator) находим валидное имя переменной, начиная с символа после $ (если длина имени 0, то оставляем $, то есть не делаем подстановку), после чего заменяем переменную на её значение и продолжаем цикл с символа после названия переменной. Все внешние кавычки не добавляются в итоговый результат

Примеры подстановок (a=9):
- '3 = | "$a" $a' -> 3 = | "$a" $a
- "3 = | '$a' $a" -> 3 = | '9' 9
- Lesha$a -> Lesha9
- "$ab" -> пустая строка
- "$a=b" -> 9=b
- "$a|b" -> 9|b
- 'a'="3" -> a=3

### PipeSplitter
Отвечает за разбиение пайпа на команды (списки токенов)

Умеет:
- поделить список токенов по токену |

### CommandFactory
Отвечает за создание команд

Умеет:
- зарегистрировать свою команду (cat, echo, ...)
- сделать из списка токенов команду

Алгоритм: Первый токен — название команды, остальные — аргументы. Если название команды зарегистрировано, то возвращает нашу реализацию, которой передаются аргументы в конструктор. Иначе будет подготовлен к запуску системный процесс, будут сразу же переданы аргументы, будут проставлены переменные окружения для него (нужен доступ к [Env](#env)) (например, с помощью [ProcessBuilder](https://docs.oracle.com/javase/8/docs/api/java/lang/ProcessBuilder.html))

Итоговая команда имеет методы:
- run(InputStream, OutputStream, ErrorStream): ExitCode
- isExit(): Bool

### Pipe
Отвечает за исполнение пайпа

Пайп исполняет команды последовательно, проверяет, является ли команда exit с помощью метода isExit() (Если является, то прекращает выполнение, возвращает 0), проверяет ExitCode каждой команды (если он отличен от 0, то заканчивает выполнение и возвращает этот код), направляет вывод одной команды на вход следующей.

### VarNameValidator
Отвечает за валидацию имен переменных

Умеет:
- проверить, является ли строка валидным именем переменной
- найти валидное имя переменной, начиная с начала строки (для "ab3 a" вернет ab3)

Имя валидное, если подходит под регулярное выражение [_a-zA-Z][_a-zA-Z0-9]*

### MainExecutor
Отвечает за объединение компонентов

0. Регистрирует команды cat, echo, ... в [CommandFactory](#commandfactory)
1. Просит у [CLI](#cli) очередное выражение
2. Спрашивает у [AssignmentParser](#assignmentparser), является ли выражение присваиванием
    - Если является, то записывает в [Env](#env) значение и переходит к шагу 1
    - Иначе идет дальше
3. Спрашивает у [PipeParser](#pipeparser), является ли выражение исполняемым
    - Если не является, то выводит ошибку с помощью CLI и переходит к шагу 1
    - Иначе идет дальше
4. Превращает списки токенов в команды с помощью [CommandFactory](#commandfactory)
5. Превращает список команд в пайп, передав их в конструктор [Pipe](#pipe)
6. Просит у [CLI](#cli) поток ввода, вывода и ошибок, передает их в пайп, проверяет ExitCode и isExit() у пайпа
    - Если isExit() true, то заканчивает работу
    - Иначе переходит к шагу 1
