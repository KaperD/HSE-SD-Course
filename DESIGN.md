# Архитектура интерпретатора командной строки hsesh

## Команда
- Бубнов Данил
- Онофрийчук Илья
- Марьин Глеб
- Лучинин Алексей

## Структурная диаграмма
![Диаграмма классов](images/class_diagram.svg)

## Компоненты

### Environment
Отвечает за переменные окружения и текущую рабочую папку

Умеет:
- Прочитать или изменить текущую рабочую папку
- присвоить какой-то переменной значение
- сказать значение конкретной переменной
- отдать весь список переменных и их значений (которые хранит сам Env, а не его родитель)
Если Env не знает про какую-то переменную, то спрашивает про неё у родителя (системы)

### CLI
Отвечает за ввод и вывод в консоль

Умеет:
- считывать очередное выражение (строку)
- вернуть потоки ввода, вывода и ошибок
- вывести строку или поток байтов в консоль

### AssignmentParser
Отвечает за присваивания

Умеет:
- проверить, является ли выражение присваиванием
- вернуть переменную и присваиваемое значение

Алгоритм: если в выражении есть =, то разбиваем выражение по первому =; проверяем, является ли левая часть валидным именем переменной (с помощью [VarNameValidator](#varnamevalidator)), а правая валидным токеном (с помощью [Tokenizer](#tokenizer)). Если является, то с помощью [Substitutor](#substitutor) преобразуем токен и возвращаем пару (ключ, значение)

Примеры корректных присваиваний:
- a=3dF_
- a=$b
- a=" = | ' $b "
- a=' = | " $b '
- a=3'3 3'3
- a=" 3 3 "
- a=' 3 3 '
- a=' $b '" $b "' 3 '
- a=3'|'
- a=3"="
- a=3=

Примеры некорректных присваиваний:
- a= 3
- a =3
- a = 3
- a=3"
- a=3'
- a='3
- a="3
- a=3|
- a=3 3
- a=$b b
- a=" 3 "|' 3 '

### PipeParser
Отвечает за пайпы

Умеет:
- проверить, является ли выражение пайпом
- вернуть список списков токенов

Алгоритм:
1. Передает [Tokenizer](#tokenizer) выражение, он возвращает нам список токенов
2. Бьет список токенов на списки токенов (будущие команды) с помощью [PipeSplitter](#pipesplitter)
3. Заменяет в каждом токене переменные с помощью [Substitutor](#substitutor) (сначала токенизировали, и разбили по |, а затем делаем подстановку, такое поведение схоже с поведением zsh)

Если на каком-то шаге произошла ошибка, то это не пайп

Примеры:
- `echo 3 | wc` --> `[[echo, 3], [wc]]`
- `echo 3 $v wc` ->> `[[echo, 3, |, wc]]` (`v='|'`)
- `echo$s=3` --> `[[echo =3]]` (`s=' '`)

### Tokenizer
Отвечает за разбиение на токены

Умеет:
- разбить выражение на токены

Токен -- это одно из:
- |
- '[^']*'
- "[^"]*"
- [^'"|\s]+
- конкатенация последних трех

Или одним регулярным выражением `(\||('[^']*'|"[^"]*"|[^'"|\s]+)+)`

Примеры корректных токенов:
- |
- '3 = | "$a" $a '
- "3 = | '$a' $a "
- Lesha9
- 9'='3"^"2
- 9'='9
- "9="9
- "3""4"

### Substitutor
Отвечает за подстановку переменных

Умеет:
- заменить переменные в токене на их значения и убирает кавычки

Алгоритм: идем циклом по символам токена, мы можем находиться в одном из 3 состояний: 1) в одинарных кавычках 2) в двойных кавычках 3) вне кавычек. Из 3 состояния можно перейти в 1 или 2, из 1 только в 3, из 2 только в 3. Если мы внутри двойных или вне кавычек и встречаем $, то с помощью [VarNameValidator](#varnamevalidator) находим валидное имя переменной, начиная с символа после $ (если длина имени 0, то оставляем $, то есть не делаем подстановку), после чего заменяем переменную на её значение и продолжаем цикл с символа после названия переменной. Все внешние кавычки не добавляются в итоговый результат

Примеры подстановок (a=9):
- '3 = | "$a" $a' -> 3 = | "$a" $a
- "3 = | '$a' $a" -> 3 = | '9' 9
- Lesha$a -> Lesha9
- "$ab" -> пустая строка
- "$a=b" -> 9=b
- "$a|b" -> 9|b
- 'a'="3" -> a=3

### PipeSplitter
Отвечает за разбиение пайпа на команды (списки токенов)

Умеет:
- поделить список токенов по токену |

### ExecutionResult
Сущность, содержащая результат выполнения

Содержит:
- exitCode: Int — код возврата
- needExit: Boolean — нужно ли прекратить работу шела

### Executable
Сущность, которую можно исполнить

Методы:
- run(InputStream, OutputStream, ErrorStream): ExecutionResult

### Command
Отвечает за исполнение команды (внутренней или внешней).
Реализует Executable

Умеет:
- Исполнить команду

### CommandFactory
Отвечает за создание команд

Умеет:
- зарегистрировать свою команду (cat, echo, ...)
- сделать из списка токенов команду

Алгоритм: Первый токен — название команды, остальные — аргументы. Если название команды зарегистрировано, то возвращает нашу реализацию, которой передаются аргументы в конструктор. Иначе будет подготовлен к запуску системный процесс, будут сразу же переданы аргументы, будут проставлены переменные окружения для него (нужен доступ к [Env](#environment)) (например, с помощью [ProcessBuilder](https://docs.oracle.com/javase/8/docs/api/java/lang/ProcessBuilder.html))

### InMemoryPipe
Отвечает за исполнение пайпа. Передача данных между командами происходит через оперативную память

Пайп исполняет команды последовательно, проверяет, является ли команда exit с помощью метода isExit() (Если является, то прекращает выполнение, возвращает 0), проверяет ExitCode каждой команды (если он отличен от 0, то заканчивает выполнение и возвращает этот код), направляет вывод одной команды на вход следующей.

### PipeFactory
Отвечает за создание пайпов

Умеет:
- сделать из списка команд пайп

### VarNameValidator
Отвечает за валидацию имен переменных

Умеет:
- проверить, является ли строка валидным именем переменной
- найти валидное имя переменной, начиная с начала строки (для "ab3 a" вернет ab3)

Имя валидное, если подходит под регулярное выражение [_a-zA-Z][_a-zA-Z0-9]*



### ExpressionExecutor
Отвечает за исполнение выражения

1. Спрашивает у [AssignmentParser](#assignmentparser), является ли выражение присваиванием
    - Если является, то записывает в [Env](#environment) значение
    - Иначе идет дальше
2. Спрашивает у [PipeParser](#pipeparser), является ли выражение исполняемым
    - Если не является, то выводит ошибку
    - Иначе идет дальше
3. Превращает списки токенов в команды с помощью [CommandFactory](#commandfactory)
4. Превращает список команд в пайп с помощью [PipeFactory](#pipefactory)
5. Исполняет пайп и возвращает результат

### HseshApplication
Отвечает за исполнение шела
1. Просит у [CLI](#cli) очередное выражение
   - Если его нет, то завершает работу
   - Если оно пустое, то просит новое
   - Иначе продолжает
2. Исполняет выражение с помощью [ExpressionExecutor](#expressionexecutor)
   - Если needExit у результата true, то завершает свою работу
   - Иначе переходит к шагу 1

### Main
Отвечает за создание всех объектов и запуск шела
1. Создает все необходимые объекты для HseshApplication
2. Регистрирует команды cat, echo, ... в [CommandFactory](#commandfactory)
3. Запускает HseshApplication

## Команды

### grep \<pattern\> [file] (-i, -A \<n\>, -w)
Выводит строки из файла в которых встретился pattern.
Если файл не задан, то берет данные из стандартного потока ввода.
`<pattern>` всегда считается регулярным выражением

Доступные флаги:
- -w — поиск только слова целиком
- -i — регистронезависимый (case-insensitive) поиск
- -A — следующее за -A число говорит, сколько строк после совпадения надо распечатать

Возвращает ошибку, если во время чтения файла или поиска с помощью регулярного выражения возникла ошибка, а также если после флага -A идет не неотрицательное число

### ls [file]
* Выводит содержимое папки (без скрытых, которые начинаются с точки)
* Если папка не задана, выводит содержимое текущей директории
* Если папка задана, выводит ее содержимое
* Если задан файл, то выводит имя файла
* Если задано регулярное выражение, выводит имена всех файлов, которые под это выражение подходят в текущей папке


### cd [file]
* Меняет текущую рабочую папку на другую
* Если папка не задана, переходит в домашнюю директорию пользователя
* Если папка задана, переходит в нее, меняет `Environment`
